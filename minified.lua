local a=require("cc.expect").expect local b={}b.X,b.Y=term.getSize()b.bigY=b.Y-2 b.startY=4 local c=0 if pocket then c=1 b.nameLen=8 b.infoLen=16 b.items=11 elseif turtle then c=2 b.nameLen=12 b.infoLen=25 b.items=4 else c=3 b.nameLen=16 b.infoLen=32 b.items=10 end local d={}for y,z in pairs(colors)do d[y]=z d[z]=y end for y,z in pairs(colours)do d[y]=z d[z]=y end local e,f=term.getSize()local function g(y,z)term.clear()term.setCursorPos(1,1)print("Grabbing a file that is required to display this page...")z=fs.combine(shell.dir(),fs.combine("modules",z))print(y,"==>",z)if fs.exists(z)or pcall(require,z)then return end local A=http.get(y)if A then print("Connected.")local B=A.readAll()A.close()local C=io.open(z,'w')if C then C:write(B):close()print("Complete.")else error("Failed to open "..tostring(z).." for writing.",2)end else error("Failed to connect to "..tostring(y),2)end end local function h(y,z)y=y or""local A=string.len(y)+1 local B,C=term.getCursorPos()local D=term.getSize()local E=false local F=-1 local G=false term.setCursorBlink(true)while true do local H=type(z)=="string"and string.rep(z:sub(1,1),string.len(y))or y term.setCursorPos(B,C)io.write(string.rep(' ',D-B+1))term.setCursorPos(B,C)local I=A-(D-B+1)if I>=0 then io.write(string.sub(H,I+1))else io.write(H)end local J=B+A-1 if J>D then J=D end term.setCursorPos(J,C)if G then local M=term.getBackgroundColor()term.setBackgroundColor(colors.white)io.write(' ')term.setBackgroundColor(M)end local K={os.pullEvent()}local L=K[1]if L=="char"then local M=K[2]if E then y=string.sub(y,1,A-1)..M..string.sub(y,A+1)else y=string.sub(y,1,A-1)..M..string.sub(y,A)end A=A+1 elseif L=="key"then local M=K[2]if M==keys.backspace then local N=A-2 if A-2<0 then N=0 end y=string.sub(y,1,N)..string.sub(y,A)A=A-1 if A<1 then A=1 end elseif M==keys.enter then term.setCursorBlink(false)print()return y elseif M==keys.right then A=A+1 if A>string.len(y)+1 then A=string.len(y)+1 end elseif M==keys.left then A=A-1 if A<1 then A=1 end elseif M==keys.up then A=1 elseif M==keys.down then A=string.len(y)+1 elseif M==keys.delete then y=string.sub(y,1,A-1)..string.sub(y,A+1)elseif M==keys.insert then if E then E=false term.setCursorBlink(true)os.cancelTimer(F)F=-1 G=false else E=true term.setCursorBlink(false)F=os.startTimer(0.4)end end elseif L=="paste"then local M=K[2]if E then y=string.sub(y,1,A-1)..M..string.sub(y,A+#M)else y=string.sub(y,1,A-1)..M..string.sub(y,A)end A=A+#M elseif L=="timer"then local M=K[2]if M==F then G=not G F=os.startTimer(0.4)end end end end local function i(y,z,A,B)if type(y)~=z then error(A.." (expected "..z..", got "..type(y)..")",B and B+1 or 3)end end local function j(y,z,A,B)if type(y)~="string"then error("Check failure: not string",2)end if string.len(y)>z then error("Page layout string "..A.." is too long (max: "..tostring(z)..", at: "..tostring(string.len(y))..")",B and B+1 or 3)end end local function k(y)i(y,"table","Page layout is not a table.")i(y.name,"string","Page: name is of wrong type.")local z="Page "..y.name..": %s is of wrong type."i(y.platform,"string",string.format(z,"platform"))if y.platform=="all"then elseif pocket and y.platform~="pocket"or turtle and y.platform~="turtle"or not pocket and not turtle and(y.platform=="pocket"or y.platform=="turtle")then error("Menu is designed for a different platform ("..y.platform..").",2)end j(y.name,b.nameLen,"page.name")i(y.info,"string",string.format(z,"info"))j(y.info,b.infoLen,"page.info")i(y.bigInfo,"string",string.format(z,"bigInfo"))term.setCursorPos(1,1)local A=write(y.bigInfo)if A>2 then error("Page "..y.name..": bigInfo is too long and prints too many ".."lines.",2)end i(y.colors,"table",string.format(z,"colors"))i(y.colors.bg,"table",string.format(z,"colors.bg"))local B={"main"}for C=1,#B do i(y.colors.bg[B[C]],"string",string.format(z,"colors.bg."..B[C]))end i(y.colors.fg,"table",string.format(z,"colors.fg"))B={"error","main","title","info","listInfo","listTitle","bigInfo","selector","arrowDisabled","arrowEnabled","input"}for C=1,#B do i(y.colors.fg[B[C]],"string",string.format(z,"colors.fg."..B[C]))end if y.selections then for C=1,#y.selections do local D=y.selections[C]local E="Page "..y.name..", selection "..tostring(C)..": %s is of wrong type."local F="page.settings["..tostring(C).."].%s"i(D.title,"string",string.format(E,"title"))j(D.title,b.nameLen,string.format(F,"title"))i(D.info,"string",string.format(E,"info"))j(D.info,b.infoLen,string.format(F,"info"))i(D.bigInfo,"string",string.format(E,"bigInfo"))term.setCursorPos(1,1)local G=write(D.bigInfo)if G>2 then error("Page "..y.name..", selection "..tostring(C)..": bigInfo is too long and prints too many ".."lines (Unknown max length).",2)end end else y.selections={}end if y.settings then for C=1,#y.settings do local D=y.settings[C]local E="Page "..y.name..", setting "..tostring(C)..": %s is of wrong type."local F="page.settings["..tostring(C).."].%s"i(D.title,"string",string.format(E,"title"))j(D.title,b.nameLen,"title")i(D.bigInfo,"string",string.format(E,"bigInfo"))term.setCursorPos(1,1)local G=write(D.bigInfo)if G>2 then error("Page "..y.name..", setting "..tostring(C)..": bigInfo is too long and prints too many ".."lines (Unknown max length).",2)end i(D.setting,"string",string.format(E,"setting"))i(D.tp,"string",string.format(E,"tp"))if D.min then i(D.min,"number",string.format(E,"min"))end if D.max then i(D.max,"number",string.format(E,"max"))end if D.tp=="password"then i(D.store,"string",string.format(E,"store"))if D.store~="plain"and D.store~="sha256"and D.store~="sha256salt"and D.store~="kristwallet"then error(string.format("Page %s, setting %d: store is not of allowed ".."values (plain, sha256, sha256salt, kristwallet)",y.name,C),2)elseif D.store~="plain"then g("https://pastebin.com/raw/6UV4qfNF","sha256.lua")end end end else y.settings={}end if y.subPages then for C=1,#y.subPages do local D=y.subPages[C]local E="Subpage %d: %s is of wrong type."i(D.name,"string",string.format(E,C,"name"))i(D.info,"string",string.format(E,C,"info"))i(D.bigInfo,"string",string.format(E,C,"bigInfo"))term.setCursorPos(1,1)local F=write(D.bigInfo)if F>2 then error("Page "..y.name..", subpage "..tostring(C)..": bigInfo is too long and prints too many ".."lines (Unknown max length).",2)end end else y.subPages={}end term.clear()end local function l(y,z)local A=#y.selections local B=#y.settings local C=#y.subPages if z>A then if z>A+B then if z==A+B+C+1 then return 1,{title=y.final or"Go back.",info="",bigInfo=""}end if z>A+B+C then return 0 end return 3,y.subPages[z-A-B]end return 2,y.settings[z-A]end return 1,y.selections[z]end local function m(y)return#y.selections+#y.settings+#y.subPages end local function n(y,z,A,B)term.setCursorPos(b.nameLen+3,b.startY+z)term.write(string.rep(' ',e-(b.nameLen+3)))term.setCursorPos(b.nameLen+3,b.startY+z)local C=term.getTextColor()term.setTextColor(d[B])term.write(y)term.setTextColor(C)os.sleep(A)end local function o(y,z,A)local B=tostring(settings.get(z.setting))if B=="nil"then B="0"end while true do term.setCursorPos(b.nameLen+3,b.startY+A)io.write(string.rep(' ',e-14))term.setCursorPos(b.nameLen+3,b.startY+A)local C=tonumber(h(B))if not C then n("Not a number",A,2,y.colors.fg.error)else local D=true if z.min and C<z.min then D=false n(string.format("Minimum: %d",z.min),A,2,y.colors.fg.error)B=tostring(z.min)end if z.max and C>z.max then D=false n(string.format("Maximum: %d",z.max),A,2,y.colors.fg.error)B=tostring(z.max)end if D then return C end end end end local function p(y,z,A)local B=tostring(d[settings.get(z.setting)])if B=="nil"then B="?"end while true do term.setCursorPos(b.nameLen+3,b.startY+A)io.write(string.rep(' ',e-14))term.setCursorPos(b.nameLen+3,b.startY+A)local C=h(B)local D=tonumber(C)if d[D]then return D elseif d[C]then return d[C]else n("Not a color.",A,2,y.colors.fg.error)end end end local function q(y,z,A)while true do term.setCursorPos(2,b.startY+A)io.write(string.rep(' ',e-1))term.setCursorPos(2,b.startY+A)term.setTextColor(d[y.colors.fg.listTitle])io.write("Password:")term.setCursorPos(b.nameLen+3,b.startY+A)io.write(string.rep(' ',e-14))term.setCursorPos(b.nameLen+3,b.startY+A)term.setTextColor(d[y.colors.fg.input])local B=h("",'*')term.setCursorPos(2,b.startY+A)io.write(string.rep(' ',e-1))term.setCursorPos(2,b.startY+A)term.setTextColor(d[y.colors.fg.listTitle])io.write("Repeat:")term.setCursorPos(b.nameLen+3,b.startY+A)io.write(string.rep(' ',e-14))term.setCursorPos(b.nameLen+3,b.startY+A)term.setTextColor(d[y.colors.fg.input])local C=h("",'*')if B==C then local D if z.store=="sha256"or z.store=="sha256salt"or z.store=="kristwallet"then local E=require("sha256")if z.store=="sha256salt"then D=math.random(1,100000)B=tostring(D)..","..B end if z.store=="kristwallet"then B="KRISTWALLET"..B end B=E.digest(B):toHex()if z.store=="kristwallet"then B=B.."-000"end end return B,D else n("Not matching!",A,2,y.colors.fg.error)end end end local function r(y,z,A)local B=false term.setTextColor(d[y.colors.fg.listTitle])term.setCursorPos(2,b.startY+A)io.write(string.rep(' ',e-1))term.setCursorPos(2,b.startY+A)io.write("You sure?")while true do term.setCursorPos(b.nameLen+3,b.startY+A)io.write(string.rep(' ',e-14))term.setCursorPos(b.nameLen+3,b.startY+A)term.setTextColor(d[y.colors.fg.input])io.write(B and"[ YES ] NO"or"  YES [ NO ]")local C,D=os.pullEvent("key")if D==keys.right or D==keys.left or D==keys.tab then B=not B elseif D==keys.enter then return B end end end local function s(y,z,A)local B,C=l(y,z)local D if B~=2 then error("Dawg something happened!",2)end term.setCursorPos(b.nameLen+3,b.startY+A)term.setTextColor(colors[y.colors.fg.input])if C.tp=="string"then local E=h(settings.get(C.setting))settings.set(C.setting,E)settings.save(y.settings.location)D=E elseif C.tp=="number"then local E=o(y,C,A)settings.set(C.setting,E)settings.save(y.settings.location)D=E elseif C.tp=="color"then local E=p(y,C,A)settings.set(C.setting,E)settings.save(y.settings.location)D=E elseif C.tp=="boolean"then local E=settings.get(C.setting)if E==nil then E=true else E=not E end settings.set(C.setting,E)settings.save(y.settings.location)D=E elseif C.tp=="password"then if r(y,C,A)then local E,F=q(y,C,A)settings.set(C.setting,E)if F then settings.set(C.setting..".salt",F)end settings.save(y.settings.location)end D=settings.get(C.setting)else n(string.format("Cannot edit type '%s'.",C.tp),A,2,y.colors.fg.error)end return y.settings.location,C.setting,D,y end local function t(y,z,A)a(1,y,"table")a(2,z,"function","nil")a(3,A,"number","nil")z=z or function()end local B=1 local C=1 local D=1 local E={}local F=false local G local H k(y)if not y.settings.location then y.settings.location=".settings"end settings.load(y.settings.location)if A then G=os.startTimer(A)end local function I()while true do term.setBackgroundColor(colors[y.colors.bg.main])term.setTextColor(colors[y.colors.fg.title])term.clear()term.setCursorPos(1,1)io.write(y.name)term.setCursorPos(1,2)term.setTextColor(colors[y.colors.fg.info])io.write(y.info)for P=0,b.items-1 do local Q,R=l(y,D+P)term.setCursorPos(2,5+P)if Q==1 then term.setTextColor(colors[y.colors.fg.listTitle])io.write(R.title)term.setCursorPos(b.nameLen+3,5+P)term.setTextColor(colors[y.colors.fg.listInfo])io.write(R.info)elseif Q==2 then local S=settings.get(R.setting)if type(S)=="string"and string.len(S)>b.infoLen then S=S:sub(1,b.infoLen-3)S=S.."..."end term.setTextColor(colors[y.colors.fg.listTitle])io.write(R.title)term.setCursorPos(b.nameLen+3,5+P)term.setTextColor(colors[y.colors.fg.listInfo])if R.tp=="string"or R.tp=="number"then io.write(S or"Error: empty")elseif R.tp=="boolean"then if S==true then io.write("  false [ true ]")elseif S==false then io.write("[ false ] true")else io.write("? false ? true ?")end elseif R.tp=="color"then io.write(S and string.format("%s (%d)",d[S],S)or"? (nil)")elseif R.tp=="password"then local T={plain="Plaintext",sha256="sha256",sha256salt="sha256 + salt",kristwallet="Kristwallet"}if pocket then io.write(S and T[R.store]or"Not yet set")else io.write(S and"Stored as "..T[R.store]or"Not yet set")end else io.write(pocket and"Unsupported"or"Unsupported type.")end elseif Q==3 then term.setTextColor(colors[y.colors.fg.listTitle])io.write(R.name)term.setTextColor(colors[y.colors.fg.listInfo])term.setCursorPos(b.nameLen+3,5+P)io.write(R.info)elseif Q~=0 then io.write("Broken.")end end local K,L=l(y,B)term.setTextColor(colors[y.colors.fg.bigInfo])term.setCursorPos(1,b.Y-2)io.write(L.bigInfo)term.setCursorPos(1,b.startY+C)term.setTextColor(colors[y.colors.fg.selector])io.write(">")term.setCursorPos(1,b.startY+b.items+1)if D+b.items>m(y)+1 then term.setTextColor(colors[y.colors.fg.arrowDisabled])else term.setTextColor(colors[y.colors.fg.arrowEnabled])end io.write(string.char(31))term.setCursorPos(1,b.startY)if D>1 then term.setTextColor(colors[y.colors.fg.arrowEnabled])else term.setTextColor(colors[y.colors.fg.arrowDisabled])end io.write(string.char(30))local function M()B=B-1 if C==1 then D=D-1 end if D<1 then D=1 end C=C-1 if C<1 then C=1 end if B<1 then B=m(y)+1 C=(m(y)+1)<b.items and(m(y)+1)or b.items D=B-b.items+1 if D<1 then D=1 end end end local function N()B=B+1 if C==b.items then D=D+1 end C=C+1 if C>b.items then C=b.items end if B>m(y)+1 then B=1 D=1 C=1 end end local O=table.pack(os.pullEvent())if O[1]=="key"then F=true local P,Q=table.unpack(O,1,2)if Q==keys.up then M()elseif Q==keys.down then N()elseif Q==keys.enter then if K==1 then H=B return elseif K==2 then local R,S,T,U=s(y,B,C)local V="Bad callback return value %d: Expected %s, got %s."local W,X,Y=z(R,S,T,U)assert(type(W)=="boolean"or type(W)=="nil",string.format(V,1,"boolean or nil",type(W)))if W then assert(type(X)=="string",string.format(V,2,"string",type(X)))assert(type(Y)=="number"or type(Y)=="nil",string.format(V,3,"number or nil",type(Y)))n(X,C,Y or 2,y.colors.fg.error)end settings.save(R)elseif K==3 then local R,S=l(y,B)if not S.colors then S.colors=y.colors end if not S.platform then S.platform=y.platform end if not S.settings then S.settings={location=y.settings.location}end if not S.settings.location then S.settings.location=y.settings.location end t(S,z)end end elseif O[1]=="mouse_scroll"then F=true if O[2]==-1 then M()else N()end elseif O[1]=="timer"and O[2]==G and not F then H=1 return end end end local function J()if G then local K for L=A,1,-1 do K=L local M=tostring(L)term.setTextColor(colors.white)term.setBackgroundColor(colors.black)term.setCursorPos(b.X-#tostring(L+1),3)io.write(string.rep(' ',#tostring(L+1)))term.setCursorPos(b.X-#M,3)io.write(M)if F then break end os.sleep(1)end term.setCursorPos(b.X-#tostring(K+1),3)term.setBackgroundColor(colors.black)io.write(string.rep(' ',#tostring(K+1)))end while true do os.pullEvent("Nonexistant")end end parallel.waitForAny(I,J)if H then return H end printError("This shouldn't happen.")printError("Please report to le github with your layout file.")os.sleep(30)end local function u(y,z)a(1,y,"string")a(2,z,"number","nil")z=z or 0 local A=io.open(y,'r')if A then local B=A:read("*a")A:close()local C,D=load("return "..tostring(B),sFilename)if not C then error(string.format("Failed to load file:\n%s",D),2+z)end return C else error(string.format("No file '%s'.",y),2)end end local function v(y,z,A)a(1,y,"string")a(2,z,"function","nil")a(3,A,"number","nil")return t(u(y,1)(),z,A)end local function w(y,z)a(1,y,"table")a(2,z,"string")if y.subPages then for A=1,#y.subPages do if y.subPages[A].name==z then return y.subPages[A]end end for A=1,#y.subPages do local B=w(y.subPages[A],z)if B then return B end end end end local function x()g("https://pastebin.com/raw/6UV4qfNF","sha256.lua")end return{display=t,displayFile=v,loadFile=u,getSubPage=w,getDependencies=x}